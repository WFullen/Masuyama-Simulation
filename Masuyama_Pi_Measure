function [estBias, estRmse, ntrialVec] = p02MeasurePi(ntrials,csvfile,r,plotsOn)
% p02MeasurePi(ntrials, csvfile, r plotsOn): this functions creates a
% simulation that is similar to the previously conducted Masuyama method;
% however, there are two main differences (namely, the centers generated by
% the function must be within the 750x750 stand, and the probability of
% selection for each tree is different - as such, we will use the
% overlapArea function to do so.

% Steps for the Pi Measure Simulation
% - Generate a uniform random x and y coordinate in [0, 750]
% - Calculate the distance between the generated point and all of the trees
% contained within the csv file
% - If the trees are within the circle generated, add the TBA divided by
% the sample area to a running total
% - Our estimate for the TBA is: t_hat = (total_area)*(TBA/sample_area)

% INPUTS: ntrials, the number of trials for which we will run our
% simulation (this will give us a good guage of what values the bias / RMSE
% start to converge to
%         csvfile, a common separated values (CSV) file that contains the
% x and y coordinates of the trees, as well as the TBA of each tree
%         r, the radius of the plots for which we will generate our
%         simulated circles and collect the TBA
%         plotsOn, a True/False statement that determines whether or not we
%         display the RMSE and Bias of Estimate plots

% OUTPUTS: estBias, a vector of the bias estimates, gives a measure of
% how different the estimated values are (on average) from the true total,
% as a percentage of the total.
%          estRmse,a vector of the root mean square error (RMSE) estimates;
% gives a measure of the variation in t_hat as a percentage of the total.
%          ntrialVec, the number of trials at which we will calculate the
%          above estimates (this will give us around 50 points)

% This is the true TBA (we will compare our simulation estimates against
% this)
t = 311.906;

% The following instantiates the three vectors that we will be calculating
% in the simulation; the while loop constructs a vector of length ~ 50, for
% which we will calculate the bias and RMSE estimates from our simulation

k=1;
while ceil(ntrials/k) > 50
    k=k+1;
end

nSample=k;

ntrialVec= nSample:nSample:ntrials; 

estBias = zeros(1, length(ntrialVec));
estRmse = zeros(1, length(ntrialVec));

% This reads in the csv file of the trees data, and parses out three
% things: the x-coordinates, y-coordinates, and the total basal area

trees = csvread(csvfile, 1, 0);
x = trees(:,end-1);
y = trees(:,end);
ba = trees(:,3);

total_area = (750)^2;

t_hat = zeros(1, ntrials);

counter = 1;

overlapVec = zeros(1, length(x));
ba_divided = zeros(1, length(x));

% We will calculate the basal area for each tree in relation to its
% overlap vector (this is what is meant that each has different quantities
% for sampling, unlike the first part of this simulation) - from this
% vector, we will also calculate the average average plot overlap (based
% upon all of the trees)

for i = 1:length(x)
   overlapVec(i) = overlapArea(x(i), y(i), r);  
   ba_divided(i) = ba(i) / overlapVec(i);
end

N = length(x);

averagePlotRad = sum(overlapVec)/ (N*(pi*r*r));

% Below are the steps that are conducted in this simulation:
%   - Calculate two random points between [0 , 750 ] (different from the
% previous part in the simulation, these points have to be in the stand)
%   - Calculate the distance between our random points and every tree in
%   the uploaded csv file
%   - Now we will take the TBAs divided by their overlap areas out of the
%   ba_divided vector and sum them up (once multiplied by the total area,
%   this will give us our t_hat estimate)
%   - If the ntrials that the "for" loop is on is divisible by the nSample
%   metric described above, we will plot it (therefore, we will calculate
%   the Bias and RMSE as set out by their respective formulas)

for i = 1:ntrials
    
    rand_center_x = ( 750 )*rand();
    rand_center_y = ( 750 )*rand();
    
    distance =  (rand_center_x - x).^2 + ( rand_center_y - y).^2;

    t_hat(i) = total_area*sum(ba_divided(distance <= r*r)) ; 
    
    if mod(i, nSample) == 0
        
        estBias(counter) = (100/t)*( (sum(t_hat(1:i)) / i ) - t);
        estRmse(counter) = (100/t)*sqrt( var(t_hat(1:i)) );
   
        counter = counter + 1;
            
    end
end

% If the plotsOn is 'on', display the plots of the bias and RMSE estimates
% for the Pi Measure Method

if strcmp(plotsOn, 'on')
    plot(ntrialVec, estBias, '*b-');
    grid on
    xlabel('Number of Trials');
    ylabel('Percentage Bias of Estimate');
    title(sprintf('Percent Bias of TBA Estimate Using Measure Pi Method \n ntrials = %5.0e, r = %d, Normalized Average Plot Area = %1.3f', ntrials, r, averagePlotRad));
    figure()
    
    plot(ntrialVec, estRmse, '*b-');
    grid on
    xlabel('Number of Trials');
    ylabel('Percentage RMSE of Estimate');
    title(sprintf('Percent RMSE of TBA Estimate Using Measure Pi Method \n ntrials = %5.0e, r = %d, Normalized Average Plot Area = %1.3f', ntrials, r, averagePlotRad));
    
end

end


function [area] = overlapArea(x, y, r)

% overlapArea(x, y, r): This function calculates the overlap of a stand
% (which in this case, is a 750 x 750 square of points for our tree
% sampling simulation) and a randomly placed circle on the stand.

% INPUTS: x, y - the x and y-coordinates respectively that describe the
% center of the circle within the stand (or out of the stand, as is the
% case of the repeated masuyama).
%         r, the radius of the aforementioned circle

% OUTPUTS: area, the area of the overlap as determined by the geometric
% formulas listed below:

xmin = 0; ymin = 0; xmax = 750; ymax = 750;

% Note: There are MANY different cases - there is a short description
% before each as to what each conditional correpsonds to

% 1. This will create a conditionals for the left side (radius outside)
% The top conditional takes care of values close to the lower left corner,
% whereas the bottom conditional corresponds to the upper left corner
if (y > 0 && y <= 750) && (x <= 0) && ((xmin - x)^2 + (ymin - y)^2 > r^2)
    R = r;
    h = x + R;
    area = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

if (y > 0 && y <= 750) && (x <= 0) && ((xmin - x)^2 + (ymax - y)^2 > r^2)
    R = r;
    h = x + R;
    area = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 2. This will create a conditional for the left side (radius inside) -
% that is, the x-value is greater than 0 but no more than r (otherwise it
% would correspond to another case later on!)

if (y >= r && y <= (750 - r)) && (x > 0 && x < r)
    R = r;
    h = R - x;
    area =  pi*R*R - ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 3. This will create a conditional for the right (radius outside) - this
% checks to see whether or not the bottom right corner is located outside
% of the circle. If it is, we use this conditional

if (y > ymin && y < ymax) && (x >= xmax) && ((xmax - x)^2 + (ymin - y)^2 > r^2)
    R = r;
    h = R - (x - 750);
    area =  ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 4. This will create a conditional for the right (radius inside)
if (y >= r && y <= (750 - r)) && ((x < 750 + r) && x > (750 - r))
    R = r;
    h = (x + R) - 750;
    area =  pi*R*R - ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 5. This will create a conditional for the bottom (radius outside) - Note:
% this one does NOT have the conditional to look at the corners like some
% of the other tests; this is because this is taken care of in other
% conditionals

if (x > 0 && x < 750) && y < 0
    R = r;
    h = y + R;
    area = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 6. This will create a conditional for the bottom (radius inside)
if (x >= r && x <= (750 - r)) && (y >= 0 && y < r)
    R = r;
    h = R - y;
    area = pi*R*R - ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end 

% 7. This will create a conditional for the top (radius outside) - Note:
% this one has conditionals to look at the point in relation to the upper
% left and upper right corners; as long as the point does not contain
% either of these corners, this conditional is triggered

if (x > 0 && x < 750) && (y > 750) && ( ( (xmin - x)^2 + (ymax - y)^2 > r^2) || ((xmax - x)^2 + (ymax - y)^2 > r^2))
    R = r;
    h = 750 - (y - R);
    area = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 8. This will create a conditional for the top (radius inside)
if (x >= r && x <= (750 - r)) && (y <= 750 && y >= (750 - r))
    R = r;
    h = (y + R) - 750;
    area =  pi*R*R - ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
end

% 9. This will create a conditional for the lower left corner (Corner
% Outside) - Note: this is the case in which the circle overlaps both the x
% = 0 and y = 0 axis but does NOT touch the corner; in this case, we need to
% do a calculation similar to the ones that only overlap one side and just
% subtract both areas that extend outside the stand from pi*r^2

if (((xmin - x)^2 + (ymin - y)^2 > r^2) && (x > 0 && x < r) && (y > 0 && y < r))
    R = r;
    h = (R - y); i = (R - x);
    area_h = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area_i = ((R^2)*acos((R - i)/R) - (R-i)*sqrt(2*R*i - i^2));
    area = pi*R*R - (area_h + area_i);
end

% 10. This will create a condition for the lower left corner (Corner
% Inside) - Note: this is the case in which the circle DOES contain the
% corner (0,0). In this case, we can calculate the overlap area as just the
% sum of a triangle and arc (similar to what we calculated in steps 1-8

if (x >= -r && x < r) && (y >= -r && y < r) && ((xmin - x)^2 + (ymin - y)^2 <= r^2)
    R = r; yval = 0; xval = 0;
    
    x1 = x + sqrt( R^2 - (y - yval)^2 );
    y1 = y + sqrt( R^2 - (x - xval)^2 );
    
    area_tri = (1/2)*(x1)*(y1);
    
    mid_x = (x1 + xval)/2;
    mid_y = (y1 + yval)/2;
    
    dist_from_center = sqrt( (x - mid_x )^2 + (y - mid_y)^2 );
    h = R - dist_from_center;
    area_arc = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area = (area_tri + area_arc);

end 

% 11. This is a condition for the lower right corner (Corner
% Inside) - Note: this is the case in which the circle DOES contain the
% corner (750,0). In this case, we can calculate the overlap area as just the
% sum of a triangle and arc (similar to what we calculated in steps 1-8

if ( x < (xmax + r) && x > (xmax - r)) && ( (y < ymin + r) && y > (ymin - r)) && ((xmax - x)^2 + (ymin - y)^2 <= r^2)
    
    R = r; yval = 0; xval = 750;
    
    x1 = x - sqrt( R^2 - (yval - y)^2 );
    y1 = y + sqrt( R^2 - (xval - x)^2 );
    
    area_tri = (1/2)*(750 - x1)*(y1);
    
    mid_x = (x1 + xval)/2;
    mid_y = (y1 + yval)/2;
    
    dist_from_center = sqrt( (x - mid_x )^2 + (y - mid_y)^2 );
    h = R - dist_from_center;
    area_arc = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area = area_tri + area_arc;
    
end

% 12. This is a conditional for the lower right corner (Corner
% Outside) - Note: this is the case in which the circle overlaps both the x
% = 750 and y = 0 axis but does NOT touch the corner; in this case, we need
% to do a calculation similar to the ones that only overlap one side and just
% subtract both areas that extend outside the stand from pi*r^2

if ((xmax - x)^2 + (ymin - y)^2 > r^2) && (x < 750 && x > (750 - r)) && (y > 0 && y < r)
    R = r;
    h = (R - y); i = R - (750 - x);
    area_h = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area_i = ((R^2)*acos((R - i)/R) - (R-i)*sqrt(2*R*i - i^2));
    area = pi*R*R - (area_h + area_i);
end

% 13. This is a conditional for the upper right corner (Corner
% Inside) - Note: this is the case in which the circle DOES contain the
% corner (750,750). In this case, we can calculate the overlap area as just the
% sum of a triangle and arc (similar to what we calculated in steps 1-8

if ( x < (xmax + r) && x > (xmax - r)) && ( (y < ymax + r) && y > (ymax - r)) && ((xmax - x)^2 + (ymax - y)^2 < r^2)
    
    R = r; yval = 750; xval = 750;
    
    x1 = x - sqrt( R^2 - (yval - y)^2 );
    y1 = y - sqrt( R^2 - (xval - x)^2 );
    
    area_tri = (1/2)*(750 - x1)*(750 - y1);
    
    mid_x = (x1 + xval)/2;
    mid_y = (y1 + yval)/2;
    
    dist_from_center = sqrt( (x - mid_x )^2 + (y - mid_y)^2 );
    h = R - dist_from_center;
    area_arc = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area = area_tri + area_arc;
    
end

% 14. This is a conditional for the upper right corner (Corner
% Outside) - Note: this is the case in which the circle overlaps both the x
% = 750 and y = 750 axis but does NOT touch the corner; in this case, we need
% to do a calculation similar to the ones that only overlap one side and just
% subtract both areas that extend outside the stand from pi*r^2

if (xmax - x)^2 + (ymax - y)^2 > r^2 && (x < 750 && x > (750 - r)) && (y < 750 && y > (750 - r))
    R = r;
    h = R - (750 - y); i = R - (750 - x);
    area_h = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area_i = ((R^2)*acos((R - i)/R) - (R-i)*sqrt(2*R*i - i^2));
    area = pi*R*R - (area_h + area_i);
end

% 15. This is a conditional for the upper left corner (Corner
% Outside) - Note: this is the case in which the circle overlaps both the x
% = 0 and y = 750 axis but does NOT touch the corner; in this case, we need
% to do a calculation similar to the ones that only overlap one side and just
% subtract both areas that extend outside the stand from pi*r^2

if ((xmin - x)^2 + (ymax - y)^2 > r^2) && (x > xmin && x < r) && (y < ymax && y > (ymax - r))
    R = r;
    h = R - (750 - y); i = R - x;
    area_h = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area_i = ((R^2)*acos((R - i)/R) - (R-i)*sqrt(2*R*i - i^2));
    area = pi*R*R - (area_h + area_i);
end

% 16. This is a conditional for the upper left corner (Corner
% Inside) - Note: this is the case in which the circle DOES contain the
% corner (0,750). In this case, we can calculate the overlap area as just the
% sum of a triangle and arc (similar to what we calculated in steps 1-8

if (x > -r && x < r) && (y < ymax + r && y > (ymax - r)) && ((xmin - x)^2 + (ymax - y)^2 < r^2)

    R = r; yval = 750; xval = 0;
    x1 = x + sqrt( R^2 - (yval - y)^2);
    y1 = y - sqrt( R^2 - (xval - x)^2);
    
    area_tri = (1/2)*(x1)*(750 - y1);
    mid_x = (x1 + xval)/2;
    mid_y = (y1 + yval)/2;

    dist_from_center = sqrt( (x - mid_x )^2 + (y - mid_y)^2 );
    h = R - dist_from_center;
    area_arc = ((R^2)*acos((R - h)/R) - (R-h)*sqrt(2*R*h - h^2));
    area = area_tri + area_arc;

end

% 17. This is a conditional that covers a circle within all the boundaries
% (if there is no overlap within the boundaries of the stand, then the
% overlap of the area is just the area of the circle)

if (x >= xmin + r && x <= (xmax - r)) && (y >= ymin + r && y <= (ymax - r))
    
    area = pi*r*r;

end

% 18. In any of the below cases, the radius is centered outside of the main
% 750-by-750 stand; if we check and see that the corner is not contained,
% then the area of overlap is zero

if ((x < xmin) && (y < ymin)) && ((xmin - x)^2 + (ymin - y)^2 > r^2)     
    area = 0;
end

if ((x > xmax) && (y < ymin)) && ((xmax - x)^2 + (ymin - y)^2 > r^2)
    area = 0;
end

if ((x < xmin) && (y > ymax)) && ((xmin - x)^2 + (ymax - y)^2 > r^2)    
    area = 0;
end

if ((x > xmax) && (y > ymax)) && ((xmax - x)^2 + (ymax - y)^2 > r^2)   
    area = 0;
end

end
